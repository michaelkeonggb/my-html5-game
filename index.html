<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cat Maze Game - 3 Stages</title>
  <style>
    body {
      background: #f0f0f0;
      text-align: center;
      font-family: sans-serif;
    }
    #canvasWrap {
      position: relative;
      display: inline-block;
      margin-top: 12px;
    }
    canvas {
      border: 2px solid #333;
      background: #fff;
      touch-action: none;
      display: block;
    }
    #overlay {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 300ms ease;
      font-family: sans-serif;
      font-size: 28px;
      color: #fff;
    }
    #overlay.show {
      opacity: 1;
      pointer-events: auto;
      background: rgba(0,0,0,0.5);
    }
    #controls { margin-top: 12px; }
    button { padding: 6px 12px; font-size: 14px; }
  </style>
</head>
<body>
  <h1>üê± Cat Maze Game - Stage <span id="stageNum">1</span></h1>

  <div id="canvasWrap">
    <canvas id="mazeCanvas" width="400" height="400" aria-label="Cat maze canvas" role="img"></canvas>
    <div id="overlay" aria-hidden="true"><div id="overlayText">Stage Complete!</div></div>
  </div>

  <div id="controls">
    <button id="resetStage">Reset Stage</button>
    <button id="randomStart">Place Cat Randomly</button>
  </div>

  <script>
    // --- Configuration ---
    const cellSize = 20;
    const rows = 20;
    const cols = 20;

    // Movement speeds (ms per cell)
    const CAT_STEP_MS_NORMAL = 100;
    const ALIEN_STEP_MS = 1000;
    const GREEN_STEP_MS = 2000;
    const PINK_STEP_MS = 200;
    const MODE_B_DURATION_MS = 10000;

    // --- Stage mazes and goals ---
    const stages = [
      {
        maze: [
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1],
          [1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1],
          [1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1],
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
          [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1],
          [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
          [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1],
          [1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
          [1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1],
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
          [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1],
          [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
          [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1],
          [1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1],
          [1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,1],
          [1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        goal: { x: 18, y: 1 }
      },
      {
        maze: [
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1],
          [1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1],
          [1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1],
          [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1],
          [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1],
          [1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1],
          [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1],
          [1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1],
          [1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],
          [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],
          [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1],
          [1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1],
          [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
          [1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1],
          [1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1],
          [1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1],
          [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1]
        ],
        goal: { x: 18, y: 18 }
      },
      {
        maze: [
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
          [1,0,1,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
          [1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],
          [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
          [1,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
          [1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1],
          [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
          [1,0,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1],
          [1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
          [1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
          [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
          [1,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
          [1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
          [1,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        goal: { x: 1, y: 1 }
      }
    ];

    // --- Canvas + DOM ---
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    const stageDisplay = document.getElementById('stageNum');
    const overlay = document.getElementById('overlay');
    const overlayText = document.getElementById('overlayText');
    const resetBtn = document.getElementById('resetStage');
    const randomStartBtn = document.getElementById('randomStart');

    // --- Entities ---
    let currentStage = 0;
    let cat = null;
    let catIsPink = false;
    let aliens = [];
    let green = null;
    let gameOver = false;
    let modeBActive = false;

    let catInterval = null;
    let alienInterval = null;
    let greenInterval = null;

    // images
    const catImg = new Image();
    catImg.src = 'cat-icon.png';
    catImg.onload = redraw;
    catImg.onerror = () => { console.warn('cat-icon.png not found ‚Äî fallback rectangle used'); redraw(); };

    const alienImg = new Image();
    alienImg.src = 'Alien.png';
    alienImg.onload = redraw;
    alienImg.onerror = () => { console.warn('Alien image failed to load; fallback blue circle used'); redraw(); };

    function temporarilyRemoveAlien(alien, position) {
      setTimeout(function() {
        if (!gameOver && currentStage >= 0 && currentStage < stages.length) {
          const occupied = aliens.some(a => a.x === position.x && a.y === position.y);
          if (!occupied && stages[currentStage].maze[position.y][position.x] === 0) {
            aliens.push({ x: position.x, y: position.y });
            redraw();
          }
        }
      }, 10000);
    }

    function getOpenCells(stageIndex) {
      const maze = stages[stageIndex].maze;
      const list = [];
      for (let y = 0; y < rows; y++)
        for (let x = 0; x < cols; x++)
          if (maze[y][x] === 0) list.push({ x, y });
      return list;
    }
    function getRandomOpenExcept(stageIndex, forbid = []) {
      const open = getOpenCells(stageIndex).slice();
      const forbiddenKeys = new Set(forbid.map(p => `${p.x},${p.y}`));
      const filtered = open.filter(p => !forbiddenKeys.has(`${p.x},${p.y}`));
      if (!filtered.length) return null;
      return filtered[Math.floor(Math.random() * filtered.length)];
    }
    function getRandomStart(stageIndex) {
      const open = getOpenCells(stageIndex);
      return open.length ? open[Math.floor(Math.random() * open.length)] : { x: 1, y: 1 };
    }

    function findPath(maze, start, target) {
      const inBounds = (x,y) => x>=0 && x<cols && y>=0 && y<rows;
      const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
      const visited = Array(rows).fill(0).map(()=>Array(cols).fill(false));
      const parent = Array(rows).fill(0).map(()=>Array(cols).fill(null));
      const q = [];
      q.push({ x: start.x, y: start.y });
      visited[start.y][start.x] = true;
      let found = false;
      while (q.length) {
        const cur = q.shift();
        if (cur.x === target.x && cur.y === target.y) { found = true; break; }
        for (const d of dirs) {
          const nx = cur.x + d.dx, ny = cur.y + d.dy;
          if (!inBounds(nx,ny)) continue;
          if (visited[ny][nx]) continue;
          if (maze[ny][nx] !== 0) continue;
          visited[ny][nx] = true;
          parent[ny][nx] = cur;
          q.push({ x: nx, y: ny });
        }
      }
      if (!found) return null;
      const path = [];
      let cur = { x: target.x, y: target.y };
      while (!(cur.x === start.x && cur.y === start.y)) {
        path.push({ x: cur.x, y: cur.y });
        cur = parent[cur.y][cur.x];
        if (!cur) break;
      }
      path.reverse();
      return path;
    }

    function manhattan(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); }

    function drawMaze() {
      const maze = stages[currentStage].maze;
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          ctx.fillStyle = maze[y][x] === 1 ? '#333' : '#eee';
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
      const goal = stages[currentStage].goal;
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(goal.x * cellSize + cellSize/2, goal.y * cellSize + cellSize/2, cellSize/5, 0, Math.PI*2);
      ctx.fill();
    }

    function drawCat() {
      if (catIsPink) {
        ctx.fillStyle = 'hotpink';
        ctx.beginPath();
        ctx.arc(cat.x * cellSize + cellSize/2, cat.y * cellSize + cellSize/2, cellSize/3, 0, Math.PI*2);
        ctx.fill();
      } else {
        if (catImg.complete && catImg.naturalWidth !== 0) {
          ctx.drawImage(catImg, cat.x * cellSize, cat.y * cellSize, cellSize, cellSize);
        } else {
          ctx.fillStyle = 'orange';
          ctx.fillRect(cat.x * cellSize + 2, cat.y * cellSize + 2, cellSize - 4, cellSize - 4);
        }
      }
    }

    function drawAliens() {
      for (const a of aliens) {
        if (alienImg.complete && alienImg.naturalWidth !== 0) {
          ctx.drawImage(alienImg, a.x * cellSize, a.y * cellSize, cellSize, cellSize);
        } else {
          ctx.fillStyle = 'blue';
          ctx.beginPath();
          ctx.arc(a.x * cellSize + cellSize/2, a.y * cellSize + cellSize/2, cellSize/4, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    function drawGreen() {
      if (!green) return;
      ctx.fillStyle = 'green';
      ctx.beginPath();
      ctx.arc(green.x * cellSize + cellSize/2, green.y * cellSize + cellSize/2, cellSize/4, 0, Math.PI*2);
      ctx.fill();
    }

    function redraw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawMaze();
      drawGreen();
      drawAliens();
      drawCat();
      stageDisplay.textContent = currentStage + 1;
    }

    function stopAllIntervals() {
      if (catInterval) { clearInterval(catInterval); catInterval = null; }
      if (alienInterval) { clearInterval(alienInterval); alienInterval = null; }
      if (greenInterval) { clearInterval(greenInterval); greenInterval = null; }
    }

    let currentCatPath = null;
    let catPathIndex = 0;
    function startCatMovementWithSpeed(path, stepMs) {
      if (!path || !path.length) return;
      if (gameOver) return;
      if (catInterval) { clearInterval(catInterval); catInterval = null; }
      currentCatPath = path.slice();
      catPathIndex = 0;
      catInterval = setInterval(() => {
        if (!currentCatPath || catPathIndex >= currentCatPath.length) {
          clearInterval(catInterval);
          catInterval = null;
          currentCatPath = null;
          return;
        }
        const next = currentCatPath[catPathIndex++];
        cat.x = next.x; cat.y = next.y;
        redraw();
        if (checkAlienCollision()) return;
        const g = stages[currentStage].goal;
        if (cat.x === g.x && cat.y === g.y) {
          stopAllIntervals();
          showOverlay('Stage Complete!', 900);
          setTimeout(() => advanceStage(), 900);
        }
      }, stepMs);
    }

    function startAliensChase() {
      if (alienInterval) { clearInterval(alienInterval); alienInterval = null; }
      alienInterval = setInterval(() => {
        if (gameOver) { clearInterval(alienInterval); alienInterval = null; return; }
        for (let i = aliens.length - 1; i >= 0; i--) {
          const a = aliens[i];
          if (a.x === cat.x && a.y === cat.y) {
            if (modeBActive) {
              const removed = aliens.splice(i,1)[0];
              temporarilyRemoveAlien(removed, { x: removed.x, y: removed.y });
            } else {
              handleGameOver();
              return;
            }
          } else {
            const maze = stages[currentStage].maze;
            if (!modeBActive) {
              const path = findPath(maze, { x: a.x, y: a.y }, { x: cat.x, y: cat.y });
              if (path && path.length > 0) {
                a.x = path[0].x; a.y = path[0].y;
              }
            } else {
              const neighbors = [
                { x: a.x+1, y: a.y }, { x: a.x-1, y: a.y },
                { x: a.x, y: a.y+1 }, { x: a.x, y: a.y-1 }
              ];
              let best = { x: a.x, y: a.y };
              let bestDist = manhattan(a, cat);
              for (const n of neighbors) {
                if (n.x < 0 || n.x >= cols || n.y < 0 || n.y >= rows) continue;
                if (stages[currentStage].maze[n.y][n.x] !== 0) continue;
                const occupied = aliens.some(other => other !== a && other.x === n.x && other.y === n.y);
                if (occupied) continue;
                const d = Math.abs(n.x - cat.x) + Math.abs(n.y - cat.y);
                if (d > bestDist) { bestDist = d; best = n; }
              }
              a.x = best.x; a.y = best.y;
            }
            if (a.x === cat.x && a.y === cat.y) {
              if (modeBActive) {
                const removed = aliens.splice(i,1)[0];
                temporarilyRemoveAlien(removed, { x: removed.x, y: removed.y });
              } else {
                handleGameOver();
                return;
              }
            }
          }
        }
        redraw();
      }, ALIEN_STEP_MS);
    }

    function startGreenChase() {
      if (greenInterval) { clearInterval(greenInterval); greenInterval = null; }
      greenInterval = setInterval(() => {
        if (gameOver || !green) { clearInterval(greenInterval); greenInterval = null; return; }
        const maze = stages[currentStage].maze;
        const path = findPath(maze, { x: green.x, y: green.y }, { x: cat.x, y: cat.y });
        if (!path || path.length === 0) return;
        const next = path[0];
        green.x = next.x; green.y = next.y;
        redraw();
        if (green.x === cat.x && green.y === cat.y) {
          triggerModeB();
        }
      }, GREEN_STEP_MS);
    }

    function checkAlienCollision() {
      if (!modeBActive) {
        for (const a of aliens)
          if (a.x === cat.x && a.y === cat.y) { handleGameOver(); return true; }
      }
      return false;
    }

    function handleGameOver() {
      stopAllIntervals();
      if (alienInterval) { clearInterval(alienInterval); alienInterval = null; }
      gameOver = true;
      showOverlay('Game Over - Alien caught the Cat', 2000);
    }

    function triggerModeB() {
      if (modeBActive) return;
      modeBActive = true;
      if (greenInterval) { clearInterval(greenInterval); greenInterval = null; }
      green = null;
      catIsPink = true;
      if (catInterval) { clearInterval(catInterval); catInterval = null; }
      if (currentCatPath && catPathIndex < currentCatPath.length) {
        const remainder = currentCatPath.slice(catPathIndex);
        startCatMovementWithSpeed(remainder, PINK_STEP_MS);
      }
      if (alienInterval) { clearInterval(alienInterval); alienInterval = null; }
      startAliensChase();
      setTimeout(() => { endModeB(); }, MODE_B_DURATION_MS);
    }

    function endModeB() {
      modeBActive = false;
      catIsPink = false;
      if (catInterval) { clearInterval(catInterval); catInterval = null; }
      if (alienInterval) { clearInterval(alienInterval); alienInterval = null; }
      addNewAlienRandom();
      placeNewGreenRandom();
      redraw();
      startAliensChase();
      startGreenChase();
      currentCatPath = null;
      catPathIndex = 0;
    }

    function addNewAlienRandom() {
      const open = getOpenCells(currentStage);
      if (!open.length) return;
      const used = new Set(aliens.map(a => `${a.x},${a.y}`));
      used.add(`${cat.x},${cat.y}`);
      for (let attempt = 0; attempt < 200; attempt++) {
        const c = open[Math.floor(Math.random() * open.length)];
        const k = `${c.x},${c.y}`;
        if (!used.has(k)) { aliens.push({ x: c.x, y: c.y }); return; }
      }
      for (const c of open) { if (!(c.x === cat.x && c.y === cat.y)) { aliens.push({ x: c.x, y: c.y }); return; } }
    }

    function placeNewGreenRandom() {
      const forbid = aliens.concat([cat]);
      const p = getRandomOpenExcept(currentStage, forbid);
      if (p) green = { x: p.x, y: p.y };
    }

    function placeAliensForStage() {
      aliens = [];
      const open = getOpenCells(currentStage);
      if (!open.length) return;
      const required = currentStage === 0 ? 1 : currentStage === 1 ? 2 : 3;
      const used = new Set();
      used.add(`${cat.x},${cat.y}`);
      let attempts = 0;
      while (aliens.length < required && attempts < 500) {
        const c = open[Math.floor(Math.random() * open.length)];
        const k = `${c.x},${c.y}`;
        if (!used.has(k)) { aliens.push({ x: c.x, y: c.y }); used.add(k); }
        attempts++;
      }
      for (let i = aliens.length -1; i >= 0; i--) {
        if (aliens[i].x === cat.x && aliens[i].y === cat.y) aliens.splice(i,1);
      }
    }

    function placeGreenForStage() {
      const forbid = aliens.concat([cat]);
      const p = getRandomOpenExcept(currentStage, forbid);
      if (p) green = { x: p.x, y: p.y };
      else green = null;
    }

    function startStage() {
      stopAllIntervals();
      gameOver = false;
      modeBActive = false;
      catIsPink = false;
      currentCatPath = null;
      catPathIndex = 0;
      cat = getRandomStart(currentStage);
      placeAliensForStage();
      placeGreenForStage();
      redraw();
      if (aliens.length) startAliensChase();
      if (green) startGreenChase();
    }

    function advanceStage() {
      currentStage = (currentStage + 1) % stages.length;
      startStage();
    }

    canvas.addEventListener('click', (e) => {
      if (gameOver) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const tx = Math.floor(mx / cellSize);
      const ty = Math.floor(my / cellSize);
      if (tx < 0 || tx >= cols || ty < 0 || ty >= rows) return;
      if (stages[currentStage].maze[ty][tx] !== 0) return;
      const maze = stages[currentStage].maze;
      const path = findPath(maze, { x: cat.x, y: cat.y }, { x: tx, y: ty });
      if (!path) { showOverlay('No path', 600); return; }
      const speed = modeBActive ? PINK_STEP_MS : CAT_STEP_MS_NORMAL;
      startCatMovementWithSpeed(path, speed);
    });

    canvas.addEventListener('touchstart', (e) => {
      if (gameOver) return;
      if (!e.touches || !e.touches[0]) return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = touch.clientX - rect.left;
      const my = touch.clientY - rect.top;
      const tx = Math.floor(mx / cellSize);
      const ty = Math.floor(my / cellSize);
      if (tx < 0 || tx >= cols || ty < 0 || ty >= rows) return;
      if (stages[currentStage].maze[ty][tx] !== 0) return;
      const maze = stages[currentStage].maze;
      const path = findPath(maze, { x: cat.x, y: cat.y }, { x: tx, y: ty });
      if (!path) { showOverlay('No path', 600); return; }
      const speed = modeBActive ? PINK_STEP_MS : CAT_STEP_MS_NORMAL;
      startCatMovementWithSpeed(path, speed);
    }, { passive: false });

    window.addEventListener('keydown', (e) => {
      if (gameOver) return;
      const key = e.key;
      let nx = cat.x, ny = cat.y;
      if (key === 'ArrowUp' || key === 'w') ny--;
      else if (key === 'ArrowDown' || key === 's') ny++;
      else if (key === 'ArrowLeft' || key === 'a') nx--;
      else if (key === 'ArrowRight' || key === 'd') nx++;
      else return;
      e.preventDefault();
      if (catInterval) { clearInterval(catInterval); catInterval = null; }
      const maze = stages[currentStage].maze;
      if (nx >= 0 && nx < cols && ny >=0 && ny < rows && maze[ny][nx] === 0) {
        cat.x = nx; cat.y = ny; redraw();
        if (!modeBActive && checkAlienCollision()) return;
        if (green && cat.x === green.x && cat.y === green.y) { triggerModeB(); }
      }
    });

    function showOverlay(message, duration = 900) {
      overlayText.textContent = message;
      overlay.classList.add('show');
      overlay.setAttribute('aria-hidden', 'false');
      setTimeout(() => {
        overlay.classList.remove('show');
        overlay.setAttribute('aria-hidden', 'true');
      }, duration);
    }

    function resetStage() {
      stopAllIntervals();
      if (alienInterval) { clearInterval(alienInterval); alienInterval = null; }
      if (greenInterval) { clearInterval(greenInterval); greenInterval = null; }
      gameOver = false;
      modeBActive = false;
      catIsPink = false;
      currentCatPath = null;
      catPathIndex = 0;
      cat = getRandomStart(currentStage);
      placeAliensForStage();
      placeGreenForStage();
      redraw();
      if (aliens.length) startAliensChase();
      if (green) startGreenChase();
    }
    resetBtn.addEventListener('click', resetStage);

    randomStartBtn.addEventListener('click', () => {
      stopAllIntervals();
      gameOver = false;
      modeBActive = false;
      catIsPink = false;
      currentCatPath = null;
      catPathIndex = 0;
      cat = getRandomStart(currentStage);
      placeAliensForStage();
      placeGreenForStage();
      redraw();
      if (aliens.length) startAliensChase();
      if (green) startGreenChase();
    });

    function initialStart() {
      currentStage = 0;
      startStage();
    }

    initialStart();
  </script>
</body>
</html>
